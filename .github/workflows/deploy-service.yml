name: Deploy Service to Cloudlab

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Service name for the Docker stack (defaults to sanitized repository name)'
        required: false
        type: string
      docker_compose_file:
        description: 'Path to docker-compose file in caller repository'
        required: true
        type: string
      environment_vars:
        description: 'JSON object of environment variables to pass to deployment'
        required: false
        type: string
        default: '{}'
      ssh_host:
        description: 'Cloudlab droplet hostname or IP address (deprecated: use secrets.ssh_host instead)'
        required: false
        type: string
        default: ''
      ssh_user:
        description: 'SSH username for deployment (deprecated: use secrets.ssh_user instead, defaults to deployer)'
        required: false
        type: string
        default: ''
      ssh_port:
        description: 'SSH port for deployment (deprecated: use secrets.ssh_port instead, defaults to 1923)'
        required: false
        type: string
        default: ''
      deploy_path:
        description: 'Deployment directory on the server (defaults to ~/cloudlab/stacks/<service_name>)'
        required: false
        type: string
      health_check_timeout:
        description: 'Timeout in seconds for health check (0 to disable)'
        required: false
        type: number
        default: 60
      enable_rollback:
        description: 'Enable automatic rollback on deployment failure'
        required: false
        type: boolean
        default: true
      environment_name:
        description: 'GitHub environment name to use for deployment (e.g., production, staging)'
        required: false
        type: string
        default: ''
    secrets:
      ssh_key:
        description: 'SSH private key for deployment'
        required: true
      ssh_host:
        description: 'Cloudlab droplet hostname or IP address'
        required: false
      ssh_user:
        description: 'SSH username for deployment'
        required: false
      ssh_port:
        description: 'SSH port for deployment'
        required: false
      deployment_secrets:
        description: 'JSON object of secret environment variables for deployment (alternative to environment_vars for secrets)'
        required: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: ${{ inputs.environment_name }}
    
    steps:
      - name: Checkout caller repository
        uses: actions/checkout@v6

      - name: Validate inputs
        id: validate
        run: |
          # Set SSH connection parameters (prefer secrets over inputs)
          SSH_HOST="${{ secrets.ssh_host }}"
          SSH_USER="${{ secrets.ssh_user }}"
          SSH_PORT="${{ secrets.ssh_port }}"
          
          # Fall back to inputs if secrets not provided
          if [ -z "$SSH_HOST" ]; then
            SSH_HOST="${{ steps.validate.outputs.ssh_host }}"
          fi
          if [ -z "$SSH_USER" ]; then
            SSH_USER="${{ steps.validate.outputs.ssh_user }}"
          fi
          if [ -z "$SSH_PORT" ]; then
            SSH_PORT="${{ steps.validate.outputs.ssh_port }}"
          fi
          
          # Set defaults for optional parameters
          if [ -z "$SSH_USER" ]; then
            SSH_USER="deployer"
          fi
          if [ -z "$SSH_PORT" ]; then
            SSH_PORT="1923"
          fi
          
          echo "ssh_host=$SSH_HOST" >> $GITHUB_OUTPUT
          echo "ssh_user=$SSH_USER" >> $GITHUB_OUTPUT
          echo "ssh_port=$SSH_PORT" >> $GITHUB_OUTPUT
          
          # Sanitize service name from repository name if not provided
          if [ -z "${{ inputs.service_name }}" ]; then
            # Extract repo name and sanitize (remove special chars, lowercase)
            REPO_NAME="${GITHUB_REPOSITORY##*/}"
            SERVICE_NAME=$(echo "$REPO_NAME" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-' | tr -d '-')
          else
            SERVICE_NAME=$(echo "${{ inputs.service_name }}" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-' | tr -d '-')
          fi
          
          # Validate that the sanitized service name is not empty
          if [ -z "$SERVICE_NAME" ]; then
            echo "Error: Service name is empty after sanitization. Use only letters (a-z) and digits (0-9) in the repository or service_name input."
            exit 1
          fi
          
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          
          # Set deployment path
          if [ -z "${{ inputs.deploy_path }}" ]; then
            DEPLOY_PATH="~/cloudlab/stacks/$SERVICE_NAME"
          else
            DEPLOY_PATH="${{ inputs.deploy_path }}"
          fi
          echo "deploy_path=$DEPLOY_PATH" >> $GITHUB_OUTPUT
          
          # Validate docker-compose file exists
          if [ ! -f "${{ inputs.docker_compose_file }}" ]; then
            echo "Error: Docker compose file not found: ${{ inputs.docker_compose_file }}"
            exit 1
          fi
          
          # Validate JSON environment variables
          if ! echo '${{ inputs.environment_vars }}' | jq empty 2>/dev/null; then
            echo "Error: Invalid JSON in environment_vars"
            exit 1
          fi
          
          echo "Deployment configuration:"
          echo "  Service: $SERVICE_NAME"
          echo "  Deploy path: $DEPLOY_PATH"
          echo "  SSH: ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }}:${{ steps.validate.outputs.ssh_port }}"

      - name: Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ssh_key }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p ${{ steps.validate.outputs.ssh_port }} -H ${{ steps.validate.outputs.ssh_host }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Test SSH connectivity
        run: |
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              -o StrictHostKeyChecking=accept-new \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} \
              "echo 'SSH connection successful'"

      - name: Backup current deployment (for rollback)
        if: inputs.enable_rollback
        id: backup
        run: |
          BACKUP_DIR="/tmp/cloudlab-backup-$(date +%s)"
          echo "backup_dir=$BACKUP_DIR" >> $GITHUB_OUTPUT
          
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} << EOF
            SERVICE_NAME="${{ steps.validate.outputs.service_name }}"
            DEPLOY_PATH="${{ steps.validate.outputs.deploy_path }}"
            BACKUP_DIR="$BACKUP_DIR"
            
            # Check if stack exists
            if docker stack ps "\$SERVICE_NAME" &>/dev/null; then
              echo "Creating backup of current deployment..."
              mkdir -p "\$BACKUP_DIR"
              
              # Save current compose file
              if [ -f "\$DEPLOY_PATH/docker-compose.yml" ]; then
                cp "\$DEPLOY_PATH/docker-compose.yml" "\$BACKUP_DIR/"
              fi
              
              # Save stack name
              echo "\$SERVICE_NAME" > "\$BACKUP_DIR/stack_name"
              
              echo "Backup created at \$BACKUP_DIR"
            else
              echo "No existing stack found, skipping backup"
            fi
          EOF

      - name: Prepare deployment directory
        run: |
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} \
              "mkdir -p ${{ steps.validate.outputs.deploy_path }}"

      - name: Copy docker-compose file
        run: |
          scp -i ~/.ssh/deploy_key \
              -P ${{ steps.validate.outputs.ssh_port }} \
              ${{ inputs.docker_compose_file }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }}:${{ steps.validate.outputs.deploy_path }}/docker-compose.yml

      - name: Validate docker-compose syntax
        run: |
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} << 'EOF'
            cd ${{ steps.validate.outputs.deploy_path }}
            if ! docker compose config --no-interpolate > /dev/null 2>&1; then
              echo "Error: Invalid docker-compose.yml syntax"
              docker compose config --no-interpolate 2>&1 || true
              exit 1
            fi
            echo "Docker compose file validation successful"
          EOF

      - name: Pull Docker images
        run: |
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} << 'EOF'
            cd ${{ steps.validate.outputs.deploy_path }}
            
            # Parse environment variables with proper shell escaping
            # Merge non-secret environment_vars with secret deployment_secrets
            ENV_VARS='${{ inputs.environment_vars }}'
            DEPLOYMENT_SECRETS='${{ secrets.deployment_secrets }}'
            
            # Merge JSON objects (secrets take precedence)
            if [ -n "$DEPLOYMENT_SECRETS" ] && [ "$DEPLOYMENT_SECRETS" != "null" ]; then
              MERGED_VARS=$(echo "$ENV_VARS" "$DEPLOYMENT_SECRETS" | jq -s '.[0] * .[1]')
            else
              MERGED_VARS="$ENV_VARS"
            fi
            
            # Export environment variables safely using eval with jq's @sh formatter
            while IFS='=' read -r key value; do
              # Validate key is a valid environment variable name
              if [[ ! "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                echo "Error: Invalid environment variable name: $key"
                exit 1
              fi
              export "$key=$value"
            done < <(echo "$MERGED_VARS" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')
            
            echo "Pulling Docker images..."
            # Use grep to extract image names from compose file instead of
            # docker compose pull, which fails on port ranges in long-form
            # syntax (e.g. target: 10000-10999). The deploy step uses
            # docker stack deploy which parses these correctly.
            PULL_FAILED=0
            while IFS= read -r image; do
              # Strip surrounding quotes and whitespace
              image=$(printf '%s\n' "$image" | tr -d '"' | xargs)
              [ -z "$image" ] && continue
              # Safely resolve ${VAR:-default} patterns using indirect
              # variable expansion instead of eval to avoid command injection
              while echo "$image" | grep -qE '\$\{[A-Za-z_][A-Za-z0-9_]*:-[^}]*\}'; do
                match=$(echo "$image" | grep -oE '\$\{[A-Za-z_][A-Za-z0-9_]*:-[^}]*\}' | head -1)
                var_name=$(echo "$match" | sed -E 's/\$\{([A-Za-z_][A-Za-z0-9_]*):-[^}]*\}/\1/')
                default_val=$(echo "$match" | sed -E 's/\$\{[A-Za-z_][A-Za-z0-9_]*:-([^}]*)\}/\1/')
                var_val="${!var_name:-$default_val}"
                image="${image/$match/$var_val}"
              done
              # Expand remaining simple ${VAR} references
              expanded=$(printf '%s\n' "$image" | envsubst)
              echo "Pulling $expanded..."
              if ! docker pull "$expanded"; then
                echo "Error: Failed to pull $expanded"
                PULL_FAILED=1
              fi
            done < <(grep -E '^[[:space:]]+image:' docker-compose.yml | sed 's/^[^:]*:[[:space:]]*//')
            if [ "$PULL_FAILED" -ne 0 ]; then
              echo "Error: One or more images failed to pull"
              exit 1
            fi
          EOF

      - name: Deploy to Docker Swarm
        id: deploy
        run: |
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} << 'EOF'
            cd ${{ steps.validate.outputs.deploy_path }}
            
            # Parse environment variables with proper shell escaping
            # Merge non-secret environment_vars with secret deployment_secrets
            ENV_VARS='${{ inputs.environment_vars }}'
            DEPLOYMENT_SECRETS='${{ secrets.deployment_secrets }}'
            
            # Merge JSON objects (secrets take precedence)
            if [ -n "$DEPLOYMENT_SECRETS" ] && [ "$DEPLOYMENT_SECRETS" != "null" ]; then
              MERGED_VARS=$(echo "$ENV_VARS" "$DEPLOYMENT_SECRETS" | jq -s '.[0] * .[1]')
            else
              MERGED_VARS="$ENV_VARS"
            fi
            
            # Export environment variables safely using eval with jq's @sh formatter
            while IFS='=' read -r key value; do
              # Validate key is a valid environment variable name
              if [[ ! "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                echo "Error: Invalid environment variable name: $key"
                exit 1
              fi
              export "$key=$value"
            done < <(echo "$MERGED_VARS" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')
            
            SERVICE_NAME="${{ steps.validate.outputs.service_name }}"
            
            echo "Deploying stack: $SERVICE_NAME"
            docker stack deploy -c docker-compose.yml --prune --resolve-image always "$SERVICE_NAME"
          EOF

      - name: Wait for services to be ready
        if: inputs.health_check_timeout > 0
        id: health_check
        timeout-minutes: 15
        run: |
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} << 'EOF'
            SERVICE_NAME="${{ steps.validate.outputs.service_name }}"
            TIMEOUT=${{ inputs.health_check_timeout }}
            
            echo "Waiting for services to be ready (timeout: ${TIMEOUT}s)"
            
            END_TIME=$(($(date +%s) + TIMEOUT))
            
            while [ $(date +%s) -lt $END_TIME ]; do
              # Get all services in the stack
              SERVICES=$(docker stack services "$SERVICE_NAME" --format "{{.Name}}" 2>/dev/null || true)
              
              if [ -z "$SERVICES" ]; then
                echo "No services found yet, waiting..."
                sleep 5
                continue
              fi
              
              ALL_READY=true
              
              for SERVICE in $SERVICES; do
                # Get replicas status (e.g., "1/1" means 1 running out of 1 desired)
                REPLICAS=$(docker service ls --filter "name=$SERVICE" --format "{{.Replicas}}" | head -n1)
                
                if [ -z "$REPLICAS" ]; then
                  echo "Service $SERVICE: No replica info yet"
                  ALL_READY=false
                  continue
                fi
                
                # Parse running/desired counts
                RUNNING=$(echo "$REPLICAS" | cut -d'/' -f1)
                DESIRED=$(echo "$REPLICAS" | cut -d'/' -f2)
                
                if [ "$RUNNING" != "$DESIRED" ]; then
                  echo "Service $SERVICE: $REPLICAS replicas (not ready)"
                  ALL_READY=false
                else
                  echo "Service $SERVICE: Ready ($REPLICAS)"
                fi
              done
              
              if [ "$ALL_READY" = true ]; then
                echo "All services are ready!"
                exit 0
              fi
              
              sleep 5
            done
            
            echo "ERROR: Timeout waiting for services to be ready"
            echo "=== Final stack status ==="
            docker stack ps "$SERVICE_NAME" --no-trunc
            echo ""
            echo "=== Service details ==="
            docker stack services "$SERVICE_NAME"
            echo ""
            echo "=== Logs from services ==="
            for SERVICE in $SERVICES; do
              echo "--- Logs for $SERVICE ---"
              docker service logs --tail 50 "$SERVICE" || echo "No logs available"
            done
            exit 1
          EOF

      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} << 'EOF'
            SERVICE_NAME="${{ steps.validate.outputs.service_name }}"
            
            echo "=== Stack Status ==="
            docker stack ps "$SERVICE_NAME"
            
            echo ""
            echo "=== Services ==="
            docker stack services "$SERVICE_NAME"
            
            # Check for failed tasks
            FAILED=$(docker stack ps "$SERVICE_NAME" --filter "desired-state=running" --format "{{.CurrentState}}" | grep -i "failed" || true)
            
            if [ -n "$FAILED" ]; then
              echo ""
              echo "WARNING: Some tasks have failed:"
              echo "$FAILED"
            fi
          EOF

      - name: Rollback on failure
        if: failure() && inputs.enable_rollback && steps.backup.outputs.backup_dir != ''
        run: |
          echo "Deployment failed, initiating rollback..."
          
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} << 'EOF'
            BACKUP_DIR="${{ steps.backup.outputs.backup_dir }}"
            
            if [ -d "$BACKUP_DIR" ] && [ -f "$BACKUP_DIR/stack_name" ]; then
              STACK_NAME=$(cat "$BACKUP_DIR/stack_name")
              DEPLOY_PATH="${{ steps.validate.outputs.deploy_path }}"
              
              echo "Rolling back to previous deployment..."
              
              # Restore compose file
              if [ -f "$BACKUP_DIR/docker-compose.yml" ]; then
                cp "$BACKUP_DIR/docker-compose.yml" "$DEPLOY_PATH/"
                
                cd "$DEPLOY_PATH"
                
                # Parse environment variables with proper shell escaping
                ENV_VARS='${{ inputs.environment_vars }}'
                
                # Export environment variables safely
                while IFS='=' read -r key value; do
                  if [[ ! "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                    echo "Error: Invalid environment variable name: $key"
                    exit 1
                  fi
                  export "$key=$value"
                done < <(echo "$ENV_VARS" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')
                
                docker stack deploy -c docker-compose.yml "$STACK_NAME"
                
                echo "Rollback completed"
              else
                echo "No backup compose file found, removing failed stack..."
                docker stack rm "$STACK_NAME"
              fi
              
              # Cleanup backup
              rm -rf "$BACKUP_DIR"
            else
              echo "No backup found, skipping rollback"
            fi
          EOF

      - name: Cleanup
        if: always()
        run: |
          # Cleanup old backups on server (keep last 5) - do this before removing SSH key
          ssh -i ~/.ssh/deploy_key \
              -p ${{ steps.validate.outputs.ssh_port }} \
              ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }} << 'EOF' || true
            cd /tmp
            ls -dt cloudlab-backup-* 2>/dev/null | tail -n +6 | xargs rm -rf 2>/dev/null || true
          EOF
          
          # Remove SSH key after all SSH operations are complete
          rm -f ~/.ssh/deploy_key

      - name: Deployment summary
        if: success()
        run: |
          echo "### Deployment Successful! :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** ${{ steps.validate.outputs.service_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deploy Path:** ${{ steps.validate.outputs.deploy_path }}" >> $GITHUB_STEP_SUMMARY
          echo "**Host:** ${{ steps.validate.outputs.ssh_host }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Use the following command to check status:" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "ssh -p ${{ steps.validate.outputs.ssh_port }} ${{ steps.validate.outputs.ssh_user }}@${{ steps.validate.outputs.ssh_host }}" >> $GITHUB_STEP_SUMMARY
          echo "docker stack ps ${{ steps.validate.outputs.service_name }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
